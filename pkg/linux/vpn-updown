#!/usr/bin/env python
# -*- coding: utf-8 -*-
# leap-vpn-updown
# Copyright (C) 2014 LEAP
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
Firewall script to modify routes before stablishing a openvpn connection, and
after tearing it down.

This script is expected to be run by using two hard links, defined under
VPN_UP_FILE and VPN_DOWN_FILE constants.
"""
import os
import subprocess
import socket
import sys
import time

import logging


VPN_UP_FILE = "vpn-up"
VPN_DOWN_FILE = "vpn-down"

INIT_CONDITION = "init"
RESTART_CONDITION = "restart"

FW_START_ACTION = "start"
FW_STOP_ACTION = "stop"

"""
The path to the script to update resolv.conf
"""

RESOLVCONF_BIN = "/sbin/resolvconf"
LEAP_UPDATE_RESOLVCONF_FILE = "/etc/leap/update-resolv-conf"
LEAP_RESOLV_UPDATE = "/etc/leap/resolv-update"


"""
The file that will keep track of the restart state, via its file attributes.
"""
TSFILE = "/tmp/leap-eip-restart"

"""
The leap firewall path
"""
LEAP_FIREWALL = "/etc/leap/leap-fw"

"""
The delta time, in seconds, to consider a down init as a bogus call, due to
restart.
"""
DELTA_RESTART = 1

VPN_GATEWAY = os.getenv('route_vpn_gateway')
DEBUG = os.getenv('DEBUG')

print "VPN GATEWAY: ", VPN_GATEWAY

if DEBUG:

    #for k, v in os.environ.items():
    #    print k, '-->', v

    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    ch.setFormatter(formatter)

    logger = logging.getLogger(__name__)
    logger.setLevel(logging.DEBUG)
    logger.addHandler(ch)

    logger.debug(' '.join(sys.argv))

condition = sys.argv[-1]
command = sys.argv[0]
script = command.split('/')[-1]


def getmtime():
    """
    Return the modification time of the timestamp file.

    :rtype: float
    """
    if os.path.isfile(TSFILE):
        return os.path.getmtime(TSFILE)


def updatemtime():
    """
    Update the modification time of the timestamp file, by touching it.
    """
    if not os.path.isfile(TSFILE):
        f = open(TSFILE, 'a')
        f.close()
    os.utime(TSFILE, None)
    # XXX should also make chown to uid=0


def recently_restarted():
    """
    Return True if the current timestamp
    is within the accepted range from the last written modification time for
    the timestamp file.

    :rtype: bool
    """
    now = time.time()
    mtime = getmtime()
    if mtime is None:
        return False

    delta = now - mtime

    if DEBUG:
        print "DELTA: ", delta

    if delta < DELTA_RESTART:
        return True
    else:
        return False


def is_valid_ipaddr(value):
    """
    Validate that the passed ip is a valid IP address.

    :param value: the value to be validated
    :type value: str
    :rtype: bool
    """
    try:
        socket.inet_aton(value)
        return True
    except Exception:
        print "MALFORMED VPN GATEWAY: %s!" % value
        return False


def fw_up():
    """
    Bring the firewall up.
    """
    if is_valid_ipaddr(VPN_GATEWAY):
        subprocess.Popen([LEAP_FIREWALL, FW_START_ACTION, VPN_GATEWAY])


def fw_down():
    """
    Tear the firewall down.
    """
    if is_valid_ipaddr(VPN_GATEWAY):
        subprocess.Popen([LEAP_FIREWALL, FW_STOP_ACTION, VPN_GATEWAY])


def has_system_resolvconf():
    """
    Return True if resolvconf is found in the system.
    """
    return os.path.isfile(RESOLVCONF_BIN)


def has_valid_update_resolvconf():
    """
    Return True if a valid update-resolv-conf script is found in the system.
    """
    return os.path.isfile(LEAP_UPDATE_RESOLVCONF_FILE)


def has_valid_leap_resolv_update():
    """
    Return True if a valid resolv-update script is found in the system.
    """
    return os.path.isfile(LEAP_RESOLV_UPDATE)


def update_resolvconf():
    """
    Try to update resolvconf.
    """
    if has_system_resolvconf():
        if has_valid_update_resolvconf():
            subprocess.Popen([LEAP_UPDATE_RESOLVCONF_FILE])
    else:
        if has_valid_leap_resolv_update():
            subprocess.Popen([LEAP_RESOLV_UPDATE])


if __name__ == "__main__":

    if script == VPN_UP_FILE and condition == INIT_CONDITION:
        print "FIREWALL UP"
        fw_up()
        print "UPDATE RESOLV.CONF"
        update_resolvconf()

    if script == VPN_UP_FILE and condition == RESTART_CONDITION:
        print "UPDATE MTIME"
        updatemtime()

    if script == VPN_DOWN_FILE and condition == INIT_CONDITION:
        if recently_restarted():
            if DEBUG:
                print "DOWN BOGUS RESTART ---> IGNORING"
        else:
            print "UPDATE RESOLV.CONF"
            update_resolvconf()
            print "FIREWALL DOWN"
            fw_down()
